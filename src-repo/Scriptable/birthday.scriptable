// --- é…ç½®åŒºåŸŸ ---
// è¯·åœ¨æ­¤å¤„å¡«å…¥ä½ çš„ GitHub Raw é“¾æ¥
const GITHUB_RAW_URL = "https://raw.githubusercontent.com/ä½ çš„ç”¨æˆ·å/ä»“åº“å/åˆ†æ”¯/æ–‡ä»¶å.js";

// --- æ•°æ®æŒä¹…åŒ–è®¾ç½® ---
let fm = FileManager.local();
const scriptPath = module.filename; // å½“å‰è„šæœ¬æ–‡ä»¶çš„è·¯å¾„
const dataPath = fm.joinPath(fm.documentsDirectory(), "lunar_birthday_data.json");

let familyData = [
  { name: "çˆ¸çˆ¸", month: 3, day: 15, emoji: "ğŸ‘¨" },
  { name: "å¦ˆå¦ˆ", month: 6, day: 20, emoji: "ğŸ‘©" },
  { name: "å¦¹å¦¹", month: 9, day: 5,  emoji: "ğŸ‘§" },
  { name: "æˆ‘",   month: 11, day: 7,  emoji: "ğŸ‘¦" }
];

if (fm.fileExists(dataPath)) {
  familyData = JSON.parse(fm.readString(dataPath));
}

// --- è¿è¡Œé€»è¾‘ ---
if (config.runsInApp) {
  await showControlPanel();
}

const widget = await createWidget(familyData);
if (config.runsInWidget) {
  Script.setWidget(widget);
} else {
  widget.presentMedium();
}
Script.complete();

// --- äº¤äº’æ§åˆ¶é¢æ¿ ---
async function showControlPanel() {
  const alert = new Alert();
  alert.title = "ğŸ‚ ç”Ÿæ—¥ç®¡å®¶é…ç½®ä¸­å¿ƒ";
  alert.message = "ç®¡ç†æˆå‘˜ç”Ÿæ—¥æˆ–åŒæ­¥ GitHub ä»£ç ";
  
  // æˆå‘˜åˆ—è¡¨
  familyData.forEach(p => alert.addAction(`${p.emoji} ä¿®æ”¹ ${p.name}`));
  
  // åŠŸèƒ½æŒ‰é’®
  alert.addDestructiveAction("ğŸ”„ æ›´æ–°è„šæœ¬ (GitHub)");
  alert.addCancelAction("ä¿å­˜å¹¶é€€å‡º");
  
  const index = await alert.presentSheet();
  
  if (index === -1) return; // å–æ¶ˆ

  // åˆ¤æ–­æ˜¯å¦ç‚¹å‡»äº†æ›´æ–°æŒ‰é’® (ç´¢å¼•åœ¨æ‰€æœ‰æˆå‘˜ä¹‹å)
  if (index === familyData.length) {
    await updateScript();
    return;
  }

  // å¦åˆ™æ˜¯ä¿®æ”¹æˆå‘˜
  const pIndex = index;
  const editAlert = new Alert();
  editAlert.title = `ç¼–è¾‘ ${familyData[pIndex].name}`;
  editAlert.addTextField("å§“å", familyData[pIndex].name);
  editAlert.addTextField("å†œå†æœˆä»½", familyData[pIndex].month.toString());
  editAlert.addTextField("å†œå†æ—¥æœŸ", familyData[pIndex].day.toString());
  editAlert.addTextField("Emoji", familyData[pIndex].emoji);
  
  editAlert.addDestructiveAction("ä¿å­˜");
  editAlert.addCancelAction("å–æ¶ˆ");
  
  if (await editAlert.present() === 0) {
    familyData[pIndex].name = editAlert.textFieldValue(0);
    familyData[pIndex].month = parseInt(editAlert.textFieldValue(1));
    familyData[pIndex].day = parseInt(editAlert.textFieldValue(2));
    familyData[pIndex].emoji = editAlert.textFieldValue(3);
    fm.writeString(dataPath, JSON.stringify(familyData));
    await showControlPanel();
  }
}

// --- æ ¸å¿ƒåŠŸèƒ½ï¼šGitHub è‡ªåŠ¨æ›´æ–° ---
async function updateScript() {
  const alert = new Alert();
  alert.title = "ç¡®è®¤æ›´æ–°ï¼Ÿ";
  alert.message = "è¿™å°†ä» GitHub ä¸‹è½½æœ€æ–°ç‰ˆæœ¬å¹¶è¦†ç›–å½“å‰ä»£ç ã€‚";
  alert.addAction("å¼€å§‹åŒæ­¥");
  alert.addCancelAction("å–æ¶ˆ");
  
  if (await alert.present() === 0) {
    try {
      let req = new Request(GITHUB_RAW_URL);
      let newCode = await req.loadString();
      
      if (newCode && newCode.includes("Script.setWidget")) {
        fm.writeString(scriptPath, newCode);
        const success = new Alert();
        success.title = "æ›´æ–°æˆåŠŸ";
        success.message = "ä»£ç å·²åŒæ­¥ï¼Œè¯·ç‚¹å‡»å®Œæˆå¹¶é‡æ–°æ‰“å¼€è„šæœ¬ã€‚";
        await success.present();
      } else {
        throw new Error("ä¸‹è½½çš„ä»£ç æ— æ•ˆæˆ–æ ¼å¼ä¸æ­£ç¡®ã€‚");
      }
    } catch (e) {
      const err = new Alert();
      err.title = "æ›´æ–°å¤±è´¥";
      err.message = e.toString();
      await err.present();
    }
  }
}

// --- å†œå†è½¬æ¢ä¸å°ç»„ä»¶ç»˜åˆ¶é€»è¾‘ (ä¿æŒä¸ä¹‹å‰ä¸€è‡´) ---
function getSolarBirthday(lunarMonth, lunarDay) {
  const now = new Date();
  const calChinese = Calendar.chinese();
  const getSolar = (y) => {
    return calChinese.dateFromComponents({year: y, month: lunarMonth, day: lunarDay});
  };
  let solarDate = getSolar(now.getFullYear());
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const bdayThisYear = new Date(solarDate.getFullYear(), solarDate.getMonth(), solarDate.getDate());
  if (today > bdayThisYear) solarDate = getSolar(now.getFullYear() + 1);
  return solarDate;
}

async function createWidget(data) {
  const listWidget = new ListWidget();
  const now = new Date();
  let birthdayPerson = null;
  const processedData = data.map(p => {
    const solar = getSolarBirthday(p.month, p.day);
    const isToday = now.getDate() === solar.getDate() && now.getMonth() === solar.getMonth();
    if (isToday) birthdayPerson = p;
    return { ...p, solarDate: solar, isToday };
  });

  if (birthdayPerson) {
    const gradient = new LinearGradient();
    gradient.colors = [new Color("#e52d27"), new Color("#b31217")];
    gradient.locations = [0, 1];
    listWidget.backgroundGradient = gradient;
  } else {
    listWidget.backgroundColor = new Color("#1c1c1e");
  }

  listWidget.setPadding(15, 10, 12, 10);

  if (birthdayPerson) {
    const wishText = listWidget.addText(`ğŸŠ ç¥ ${birthdayPerson.name} ç”Ÿæ—¥å¿«ä¹ï¼ ğŸŠ`);
    wishText.font = Font.boldSystemFont(12);
    wishText.textColor = Color.white();
    wishText.centerAlignText();
    listWidget.addSpacer(8);
  }

  const mainStack = listWidget.addStack();
  mainStack.layoutHorizontally();

  for (let i = 0; i < processedData.length; i++) {
    const p = processedData[i];
    const pStack = mainStack.addStack();
    pStack.layoutVertically();
    pStack.centerAlignContent();

    const diff = p.solarDate - now;
    const progress = p.isToday ? 1 : Math.min(Math.max(1 - (diff / (1000 * 60 * 60 * 24 * 365)), 0), 1);
    
    const ctx = new DrawContext();
    ctx.size = new Size(100, 100);
    ctx.opaque = false;
    const arcColor = p.isToday ? new Color("#34c759") : new Color("#ffd60a");
    drawArc(ctx, 100, 1, new Color("#ffffff", 0.2)); 
    drawArc(ctx, 100, progress, arcColor); 
    
    ctx.setFont(Font.systemFont(40));
    ctx.setTextAlignedCenter();
    ctx.drawTextInRect(p.isToday ? "ğŸ‚" : p.emoji, new Rect(0, 22, 100, 50));

    const chartImg = pStack.addImage(ctx.getImage());
    chartImg.imageSize = new Size(75, 75);
    
    pStack.addSpacer(4);
    const nameText = pStack.addText(p.name);
    nameText.font = Font.boldSystemFont(12);
    nameText.textColor = Color.white();
    nameText.centerAlignText();
    
    const df = new DateFormatter();
    df.dateFormat = "MM/dd";
    const dateText = pStack.addText(p.isToday ? "TODAY" : df.string(p.solarDate));
    dateText.font = Font.systemFont(10);
    dateText.textColor = Color.white();
    dateText.textOpacity = 0.6;
    dateText.centerAlignText();

    if (i < processedData.length - 1) mainStack.addSpacer();
  }

  listWidget.addSpacer();

  const yearProgress = getYearProgress();
  const bottomStack = listWidget.addStack();
  bottomStack.layoutVertically();
  const progressLabel = bottomStack.addText(`${now.getFullYear()}å¹´è¿›åº¦: ${Math.floor(yearProgress * 100)}%`);
  progressLabel.font = Font.systemFont(9);
  progressLabel.textColor = Color.white();
  progressLabel.textOpacity = 0.5;
  bottomStack.addSpacer(4);
  bottomStack.addImage(drawProgressBar(400, 8, yearProgress, birthdayPerson ? new Color("#ffd60a") : new Color("#34c759")));

  return listWidget;
}

function drawArc(ctx, size, progress, color) {
  const center = size / 2;
  const radius = 40;
  const thickness = 6;
  for (let i = 0; i <= 180 * progress; i += 2) {
    const angle = (180 + i) * Math.PI / 180;
    const x = center + radius * Math.cos(angle) - thickness/2;
    const y = center + radius * Math.sin(angle) - thickness/2;
    ctx.setFillColor(color);
    ctx.fillEllipse(new Rect(x, y, thickness, thickness));
  }
}

function drawProgressBar(w, h, progress, color) {
  const ctx = new DrawContext();
  ctx.size = new Size(w, h); ctx.opaque = false;
  const bgPath = new Path();
  bgPath.addRoundedRect(new Rect(0, 0, w, h), h/2, h/2);
  ctx.addPath(bgPath); ctx.setFillColor(new Color("#ffffff", 0.2)); ctx.fillPath();
  const fgPath = new Path();
  fgPath.addRoundedRect(new Rect(0, 0, w * progress, h), h/2, h/2);
  ctx.addPath(fgPath); ctx.setFillColor(color); ctx.fillPath();
  return ctx.getImage();
}

function getYearProgress() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 1);
  const end = new Date(now.getFullYear() + 1, 0, 1);
  return (now - start) / (end - start);
}
