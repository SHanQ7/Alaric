// --- æ•°æ®æŒä¹…åŒ–è®¾ç½® ---
let fm = FileManager.local();
const path = fm.joinPath(fm.documentsDirectory(), "lunar_birthday_data.json");

// åˆå§‹æ•°æ® (å†œå†æœˆæ—¥)
let familyData = [
  { name: "çˆ¸çˆ¸", month: 3, day: 15, emoji: "ğŸ‘¨" },
  { name: "å¦ˆå¦ˆ", month: 6, day: 20, emoji: "ğŸ‘©" },
  { name: "å¦¹å¦¹", month: 9, day: 5,  emoji: "ğŸ‘§" },
  { name: "æˆ‘",   month: 11, day: 7,  emoji: "ğŸ‘¦" } // 2025å¹´å†œå†11æœˆåˆ7å³12æœˆ26æ—¥(ä»Šå¤©)
];

if (fm.fileExists(path)) {
  familyData = JSON.parse(fm.readString(path));
}

// --- è¿è¡Œé€»è¾‘ ---
if (config.runsInApp) {
  await showControlPanel();
}

const widget = await createWidget(familyData);
if (config.runsInWidget) {
  Script.setWidget(widget);
} else {
  widget.presentMedium();
}
Script.complete();

// --- å†œå†è½¬æ¢æ ¸å¿ƒå‡½æ•° ---
function getSolarBirthday(month, day) {
  const now = new Date();
  const getDate = (y) => {
    let components = new DateComponents();
    components.year = y;
    components.month = month;
    components.day = day;
    return Calendar.chinese().dateFromComponents(components);
  };

  let solarDate = getDate(now.getFullYear());
  // å¦‚æœä»Šå¹´å†œå†ç”Ÿæ—¥å·²è¿‡ï¼ˆä¸”ä¸æ˜¯ä»Šå¤©ï¼‰ï¼Œç®—æ˜å¹´çš„
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const bdayStart = new Date(solarDate.getFullYear(), solarDate.getMonth(), solarDate.getDate());
  
  if (todayStart > bdayStart) {
    solarDate = getDate(now.getFullYear() + 1);
  }
  return solarDate;
}

// --- äº¤äº’æ§åˆ¶é¢æ¿ ---
async function showControlPanel() {
  const alert = new Alert();
  alert.title = "ğŸ‚ ç”Ÿæ—¥ç®¡å®¶ & æƒŠå–œé…ç½®";
  alert.message = "ç‚¹å‡»æˆå‘˜ä¿®æ”¹å†œå†ç”Ÿæ—¥";
  familyData.forEach(p => alert.addAction(`${p.emoji} ${p.name}`));
  alert.addCancelAction("ä¿å­˜å¹¶é€€å‡º");
  
  const index = await alert.presentSheet();
  if (index === -1) return;

  const editAlert = new Alert();
  editAlert.title = `ç¼–è¾‘ ${familyData[index].name}`;
  editAlert.addTextField("å§“å", familyData[index].name);
  editAlert.addTextField("å†œå†æœˆä»½", familyData[index].month.toString());
  editAlert.addTextField("å†œå†æ—¥æœŸ", familyData[index].day.toString());
  editAlert.addTextField("Emoji", familyData[index].emoji);
  
  editAlert.addDestructiveAction("ç¡®å®š");
  editAlert.addCancelAction("å–æ¶ˆ");
  
  if (await editAlert.present() === 0) {
    familyData[index].name = editAlert.textFieldValue(0);
    familyData[index].month = parseInt(editAlert.textFieldValue(1));
    familyData[index].day = parseInt(editAlert.textFieldValue(2));
    familyData[index].emoji = editAlert.textFieldValue(3);
    fm.writeString(path, JSON.stringify(familyData));
    await showControlPanel();
  }
}

// --- å°ç»„ä»¶ç»˜åˆ¶ ---
async function createWidget(data) {
  const listWidget = new ListWidget();
  const now = new Date();
  
  // æ£€æŸ¥æ˜¯å¦æœ‰æˆå‘˜ä»Šå¤©è¿‡ç”Ÿæ—¥
  let birthdayPerson = null;
  const processedData = data.map(p => {
    const solar = getSolarBirthday(p.month, p.day);
    const isToday = now.getDate() === solar.getDate() && now.getMonth() === solar.getMonth();
    if (isToday) birthdayPerson = p;
    return { ...p, solarDate: solar, isToday };
  });

  // --- èƒŒæ™¯è®¾ç½® ---
  if (birthdayPerson) {
    // ç”Ÿæ—¥æ¨¡å¼ï¼šåä¸½çš„é‡‘è‰²/çº¢è‰²æ¸å˜
    const gradient = new LinearGradient();
    gradient.colors = [new Color("#e52d27"), new Color("#b31217")];
    gradient.locations = [0, 1];
    listWidget.backgroundGradient = gradient;
  } else {
    // æ™®é€šæ¨¡å¼ï¼šæ·±è‰²èƒŒæ™¯
    listWidget.backgroundColor = new Color("#1c1c1e");
  }

  listWidget.setPadding(15, 10, 12, 10);

  // ç”Ÿæ—¥å½“å¤©é¡¶éƒ¨æç¤º
  if (birthdayPerson) {
    const wishText = listWidget.addText(`ğŸŠ ç¥ ${birthdayPerson.name} ç”Ÿæ—¥å¿«ä¹ï¼ ğŸŠ`);
    wishText.font = Font.boldSystemFont(12);
    wishText.textColor = Color.white();
    wishText.centerAlignText();
    listWidget.addSpacer(8);
  }

  const mainStack = listWidget.addStack();
  mainStack.layoutHorizontally();

  for (let i = 0; i < processedData.length; i++) {
    const p = processedData[i];
    const pStack = mainStack.addStack();
    pStack.layoutVertically();
    pStack.centerAlignContent();

    // è®¡ç®—è¿›åº¦
    const diff = p.solarDate - now;
    const progress = p.isToday ? 1 : Math.min(Math.max(1 - (diff / (1000 * 60 * 60 * 24 * 365)), 0), 1);
    
    // ç»˜å›¾
    const ctx = new DrawContext();
    ctx.size = new Size(100, 100);
    ctx.opaque = false;
    
    // å¦‚æœæ˜¯ä»Šå¤©ï¼Œåœ†ç¯å˜äº®ç»¿è‰²ï¼Œå¦åˆ™é»„è‰²
    const arcColor = p.isToday ? new Color("#34c759") : new Color("#ffd60a");
    drawArc(ctx, 100, 1, new Color("#ffffff", 0.2)); 
    drawArc(ctx, 100, progress, arcColor); 
    
    ctx.setFont(Font.systemFont(40));
    ctx.setTextAlignedCenter();
    ctx.drawTextInRect(p.isToday ? "ğŸ‚" : p.emoji, new Rect(0, 22, 100, 50));

    const chartImg = pStack.addImage(ctx.getImage());
    chartImg.imageSize = new Size(75, 75);
    
    pStack.addSpacer(4);
    const nameText = pStack.addText(p.name);
    nameText.font = Font.boldSystemFont(12);
    nameText.textColor = Color.white();
    nameText.centerAlignText();
    
    const df = new DateFormatter();
    df.dateFormat = "MM/dd";
    const dateText = pStack.addText(p.isToday ? "TODAY" : df.string(p.solarDate));
    dateText.font = Font.systemFont(10);
    dateText.textColor = Color.white();
    dateText.textOpacity = 0.6;
    dateText.centerAlignText();

    if (i < processedData.length - 1) mainStack.addSpacer();
  }

  listWidget.addSpacer();

  // åº•éƒ¨è¿›åº¦æ¡
  const yearProgress = getYearProgress();
  const bottomStack = listWidget.addStack();
  bottomStack.layoutVertically();
  const progressLabel = bottomStack.addText(`${now.getFullYear()}å¹´è¿›åº¦: ${Math.floor(yearProgress * 100)}%`);
  progressLabel.font = Font.systemFont(9);
  progressLabel.textColor = Color.white();
  progressLabel.textOpacity = 0.5;
  bottomStack.addSpacer(4);
  bottomStack.addImage(drawProgressBar(400, 8, yearProgress, birthdayPerson ? new Color("#ffd60a") : new Color("#34c759")));

  return listWidget;
}

// --- è¾…åŠ©å‡½æ•° ---
function drawArc(ctx, size, progress, color) {
  const center = size / 2;
  const radius = 40;
  const thickness = 6;
  for (let i = 0; i <= 180 * progress; i += 2) {
    const angle = (180 + i) * Math.PI / 180;
    const x = center + radius * Math.cos(angle) - thickness/2;
    const y = center + radius * Math.sin(angle) - thickness/2;
    ctx.setFillColor(color);
    ctx.fillEllipse(new Rect(x, y, thickness, thickness));
  }
}

function drawProgressBar(w, h, progress, color) {
  const ctx = new DrawContext();
  ctx.size = new Size(w, h);
  ctx.opaque = false;
  const bgPath = new Path();
  bgPath.addRoundedRect(new Rect(0, 0, w, h), h/2, h/2);
  ctx.addPath(bgPath);
  ctx.setFillColor(new Color("#ffffff", 0.2));
  ctx.fillPath();
  const fgPath = new Path();
  fgPath.addRoundedRect(new Rect(0, 0, w * progress, h), h/2, h/2);
  ctx.addPath(fgPath);
  ctx.setFillColor(color);
  ctx.fillPath();
  return ctx.getImage();
}

function getYearProgress() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 1);
  const end = new Date(now.getFullYear() + 1, 0, 1);
  return (now - start) / (end - start);
}
